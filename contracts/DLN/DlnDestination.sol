// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.17;

import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "../interfaces/IERC20Permit.sol";
import "../interfaces/IExternalCallAdapter.sol";
import "../libraries/BytesLib.sol";
import "../libraries/EncodeSolanaDlnMessage.sol";
import "./DlnBase.sol";
import "./DlnSource.sol";
import "@debridge-finance/debridge-contracts-v1/contracts/libraries/Flags.sol";
import "../interfaces/IDlnDestination.sol";
import {Permit} from "../libraries/Permit.sol";

contract DlnDestination is DlnBase, ReentrancyGuardUpgradeable, IDlnDestination {
    using BytesLib for bytes;
    using Permit for address;

    /* ========== CONSTANTS ========== */
    uint32 constant MAX_UINT32 = 2**32 - 1;

    /// @notice Amount divider to adjust native assets when transferring from EVM to Solana.
    /// @dev Solana supports u64 integers, unlike EVM which supports u256. This constant helps
    /// in adjusting amounts considering the difference in supported integer sizes, ensuring compatibility
    /// when transferring assets between the two chains. The adjustment takes into account EVM's 18 decimals
    /// against Solana's 8 decimals.
    uint256 public constant NATIVE_AMOUNT_DIVIDER_FOR_TRANSFER_TO_SOLANA = 1e10;

    /* ========== STATE VARIABLES ========== */

    /// @dev Mapping of each chainId to the address of the dlnSource contract on that chain.
    mapping(uint256 => bytes) public dlnSourceAddresses;

    /// @dev Mapping of orderId to the state of the order.
    mapping(bytes32 => OrderTakeState) public takeOrders;

    /// @dev Storage for patches that subtract from `Order.takeAmount` during the `fulfillOrder` function call.
    mapping(bytes32 => uint256) public takePatches;

    /// @dev The maximum number of orders allowed in a batch for unlocking on the EVM-based chain.
    uint256 public maxOrderCountPerBatchEvmUnlock;

    /// @dev Maximum number of orders allowed per batch for unlocking from EVM to Solana.
    uint256 public maxOrderCountPerBatchSolanaUnlock;

    /// @dev The address of the external call adapter contract responsible for executing external calls in orders.
    address public externalCallAdapter;

    /// @dev Subscription (generated by the Subscription contract) that is used instead of chain id
    uint32 public subscriptionId;

    /* ========== ENUMS ========== */

    /**
     * @dev Enum defining the status of an order in take chain.
     * - `NotSet`: Indicates that the order is not yet set (0).
     * - `Fulfilled`: Indicates that the order has been fully filled (1).
     * - `SentUnlock`: Indicates that the unlock command for the order has been sent by the taker (2).
     * - `SentCancel`: Indicates that the order has been canceled (3).
     */
    enum OrderTakeStatus {
        NotSet, // 0
        Fulfilled, // 1
        SentUnlock, // 2
        SentCancel // 3
    }

    /* ========== STRUCTS ========== */

    /**
     * @dev Struct representing the state of order in "take" chain.
     *
     * - `status`: Indicates the status of the order, including whether it's fulfilled, unlock commands sent, or canceled.
     * - `takerAddress`: The address of the taker who claimed the order, responsible for fulfilling or canceling it.
     * - `giveChainId`: The chain ID associated with the "give" part of the order.
     */
    struct OrderTakeState {
        OrderTakeStatus status;
        address takerAddress;
        // use giveChainId it chainId less then uint32 max
        uint32 giveChainId;
        // use bigGiveChainId it chainId more then uint32 max
        uint256 bigGiveChainId;
    }

    /* ========== EVENTS ========== */

    event FulfilledOrder(DlnOrderLib.Order order, bytes32 orderId, address sender, address unlockAuthority);

    event DecreasedTakeAmount(bytes32 orderId, uint256 orderTakeFinalAmount);

    event SentOrderCancel(DlnOrderLib.Order order, bytes32 orderId, bytes cancelBeneficiary, bytes32 submissionId);

    event SentOrderUnlock(bytes32 orderId, bytes beneficiary, bytes32 submissionId);

    event SetDlnSourceAddress(uint256 chainIdFrom, bytes dlnSourceAddress, DlnOrderLib.ChainEngine chainEngine);

    event ExternalCallAdapterUpdated(address oldAdapter, address newAdapter);

    event MaxOrderCountPerBatchEvmUnlockChanged(uint256 oldValue, uint256 newValue);

    event MaxOrderCountPerBatchSolanaUnlockChanged(uint256 oldValue, uint256 newValue);

    /* ========== ERRORS ========== */

    /// @dev Thrown if the taker's amount for an order doesn't match the expected.
    error MismatchTakerAmount();

    /// @dev Thrown if native token amount (e.g., ETH) sent by the taker doesn't match
    /// the expected amount for order fulfillment.
    error MismatchNativeTakerAmount();

    /// @dev Thrown if there's a `giveTokenAddress` mismatch among orders
    /// in a Solana batch unlock.
    error WrongToken();

    /// @dev Thrown if the order has a specified `allowedCancelBeneficiarySrc` and
    /// the provided `_cancelBeneficiary` argument during order cancellation does
    /// not match the expected beneficiary.
    error AllowOnlyForBeneficiary(bytes expectedBeneficiary);

    /// @dev Thrown if batch size of orders is either 0 or exceeds the max allowed
    /// order count for a batch unlock.
    error UnexpectedBatchSize();

    /// @dev Thrown if there's a `giveChainId` mismatch among orders in a batch unlock.
    error MismatchGiveChainId();

    /// @dev Thrown if the transferred amount doesn't cover fees. Ensures amount
    /// for fixed fees, transfer fees, execution fees, and Solana call rewards.
    error TransferAmountNotCoverFees();

    /* ========== CONSTRUCTOR  ========== */

    /// @dev Constructor that initializes the most important configurations.
    function initialize(IDeBridgeGate _deBridgeGate, uint32 _subscriptionId) public initializer {
        __DlnBase_init(_deBridgeGate);
        __ReentrancyGuard_init();
         subscriptionId = _subscriptionId;
    }

    /* ========== PUBLIC METHODS ========== */

    /**
     * @inheritdoc IDlnDestination
     */
    function fulfillOrder(
        DlnOrderLib.Order memory _order,
        uint256 _fulFillAmount,
        bytes32 _orderId,
        bytes calldata _permitEnvelope,
        address _unlockAuthority
    ) external payable nonReentrant whenNotPaused {
        _fulfillOrder(
            _permitEnvelope,
            _order,
            _fulFillAmount,
            _orderId,
            _unlockAuthority,
            address(0)
        );
    }

    /**
     * @inheritdoc IDlnDestination
     */
    function fulfillOrder(
        DlnOrderLib.Order memory _order,
        uint256 _fulFillAmount,
        bytes32 _orderId,
        bytes calldata _permitEnvelope,
        address _unlockAuthority,
        address _externalCallRewardBeneficiary
    ) external payable nonReentrant whenNotPaused {
        _fulfillOrder(
            _permitEnvelope,
            _order,
            _fulFillAmount,
            _orderId,
            _unlockAuthority,
            _externalCallRewardBeneficiary
        );
    }

    function _fulfillOrder(
        bytes memory _permitEnvelope,
        DlnOrderLib.Order memory _order,
        uint256 _fulFillAmount,
        bytes32 _orderId,
        address _unlockAuthority,
        address _externalCallRewardBeneficiary
    ) internal {
        if (_order.takeChainId != getChainId()) revert WrongChain();
        bytes32 orderId = DlnOrderLib.getOrderId(_order);
        if (orderId != _orderId) revert MismatchedOrderId();
        OrderTakeState storage orderState = takeOrders[orderId];
        // in dst chain order will start from 0-NotSet
        if (orderState.status != OrderTakeStatus.NotSet) revert IncorrectOrderStatus();
        // Check that the given unlock authority equals allowedTakerDst if allowedTakerDst was set
        if (
            _order.allowedTakerDst.length > 0 &&
            BytesLib.toAddress(_order.allowedTakerDst, 0) != _unlockAuthority

        ) revert Unauthorized();
        // amount that taker need to pay to fulfill order
        uint256 takerAmount = takePatches[orderId] == 0
            ? _order.takeAmount
            : _order.takeAmount - takePatches[orderId];
        // extra check that taker paid correct amount;
        if (takerAmount != _fulFillAmount) revert MismatchTakerAmount();

        //Avoid Stack too deep
        {
            address takeTokenAddress = _order.takeTokenAddress.toAddress();
            // Need to send token to call adapter if exist external call
            address tokenReceiver = _order.externalCall.length > 0
                ? externalCallAdapter
                : _order.receiverDst.toAddress();

            if (takeTokenAddress == address(0)) {
                if (msg.value != takerAmount) revert MismatchNativeTakerAmount();
                _safeTransferETH(tokenReceiver, takerAmount);
            }
            else
            {
                takeTokenAddress.executePermit(_permitEnvelope);

                _safeTransferFrom(
                    takeTokenAddress,
                    msg.sender,
                    tokenReceiver,
                    takerAmount
                );
            }
        }
        //change order state to FulFilled
        orderState.status = OrderTakeStatus.Fulfilled;
        orderState.takerAddress = _unlockAuthority;
        //gas optimisation to save in storage
        if (_order.giveChainId < MAX_UINT32) {
            orderState.giveChainId = uint32(_order.giveChainId);
        }
        else {
             orderState.bigGiveChainId = _order.giveChainId;
        }
        if (_order.externalCall.length > 0) {
            IExternalCallAdapter(externalCallAdapter).receiveCall(
                orderId,
                _order.orderAuthorityAddressDst.toAddress(),
                _order.takeTokenAddress.toAddress(),
                takerAmount,
                _order.externalCall,
                _externalCallRewardBeneficiary
                );
        }
        emit FulfilledOrder(_order, orderId, msg.sender, _unlockAuthority);
    }

    /**
     * @dev Initiates the unlocking process for a single order's `give` part on an EVM chain.
     *
     * @notice This function is designed for unlocking assets on EVM chains for orders that have been filled.
     *         It prepares the state of an order for unlocking and sends a cross-chain message to the target
     *         chain indicated by the order's `giveChainId`. On the receiving chain, the `claim_unlock`
     *         method is expected to be called, completing the unlock process. The taker of the order is
     *         responsible for the execution fee, which is an incentive for the keepers to perform the
     *         unlock on the target chain.
     *
     * @param _orderId The unique identifier of the order that needs unlocking.
     * @param _beneficiary The recipient's address on the `giveChainId` where the assets will be unlocked to.
     * @param _executionFee The fee provided to incentivize the keepers to execute the unlock on the target chain.
     *
     * Emits a {SentOrderUnlock} event.
     *
     * Requirements:
     * - The function caller must be the taker of the order.
     */
    function sendEvmUnlock(
        bytes32 _orderId,
        address _beneficiary,
        uint256 _executionFee
    ) external payable nonReentrant whenNotPaused {
        uint256 giveChainId = _prepareOrderStateForUnlock(_orderId, DlnOrderLib.ChainEngine.EVM);
        // encode function that will be called in target chain
        bytes memory claimUnlockMethod = _encodeClaimUnlock(_orderId, _beneficiary);
        //send crosschain message through deBridgeGate
        bytes32 submissionId = _sendCrossChainMessage(
            giveChainId, // _chainIdTo
            abi.encodePacked(_beneficiary),
            _executionFee,
            claimUnlockMethod
        );

        emit SentOrderUnlock(_orderId, abi.encodePacked(_beneficiary), submissionId);
    }


    /**
     * @dev Sends a batch of unlock orders on the EVM chain based on their giveChainId.
     * @notice This method is used to unlock multiple orders that have been filled on the EVM chain,
     *         but haven't been unlocked yet. It sends a batch unlock request using the `_orderIds`
     *         provided. It's expected that all these orders share the same `giveChainId`.
     *         On the receiving chain, the `dln::source::claim_unlock` will be invoked.
     *
     * @param _orderIds Array of order IDs to unlock. All orders must have the same giveChainId.
     *        An order's giveChainId indicates the chain where the assets to be given reside.
     * @param _beneficiary Address that will receive the give amount on the give chain.
     * @param _executionFee Execution fee covering auto-claim by keepers.
     *
     * Emits a {SentOrderUnlock} event for each order in the batch.
     *
     * Requirements:
     * - Caller must be the taker of the order.
     * - The order IDs provided must not exceed the maximum allowed batch size.
     * - All the orders in the batch must have the same giveChainId.
     */
    function sendBatchEvmUnlock(
        bytes32[] memory _orderIds,
        address _beneficiary,
        uint256 _executionFee
    ) external payable nonReentrant whenNotPaused {
        if (_orderIds.length == 0) revert UnexpectedBatchSize();
        if (_orderIds.length > maxOrderCountPerBatchEvmUnlock) revert UnexpectedBatchSize();

        uint256 giveChainId;
        uint256 length = _orderIds.length;
        for (uint256 i; i < length; ++i) {
            uint256 currentGiveChainId = _prepareOrderStateForUnlock(_orderIds[i], DlnOrderLib.ChainEngine.EVM);
            if (i == 0) {
                giveChainId = currentGiveChainId;
            }
            else {
                // giveChainId must be the same for all orders
                if (giveChainId != currentGiveChainId) revert MismatchGiveChainId();
            }
        }
        // encode function that will be called in target chain
        bytes memory claimUnlockMethod = _encodeBatchClaimUnlock(_orderIds, _beneficiary);

        //send crosschain message through deBridgeGate
        bytes32 submissionId = _sendCrossChainMessage(
            giveChainId, // _chainIdTo
            abi.encodePacked(_beneficiary),
            _executionFee,
            claimUnlockMethod
        );

        for (uint256 i; i < length; ++i) {
            emit SentOrderUnlock(_orderIds[i], abi.encodePacked(_beneficiary), submissionId);
        }
    }

    /**
     * @dev Sends multiple claim_unlock instructions to unlock several orders that was created from the Solana blockchain and filled on EVM.
     * @notice Assumes all orders share the same giveChainId, giveTokenAddress, and beneficiary, so only one
     *         init_wallet_if_needed instruction is required. This batch function processes multiple orders in one transaction,
     *         generating cross-chain instructions to handle the unlocks on Solana.
     *
     * @param _orders Array of orders to unlock.
     * @param _beneficiary Address that will receive give amount in give chain.
     * @param _executionFee Execution fee for auto claim by keepers. This fee must cover a single _initWalletIfNeededInstructionReward
     *                     and _claimUnlockInstructionReward * number of orders in this batch.
     * @param _initWalletIfNeededInstructionReward Reward for executing the `init_wallet_if_needed` instruction on Solana.
     * @param _claimUnlockInstructionReward Reward for executing a single `claim_unlock` instruction on Solana. This method
     *                      sends as many claim_unlock instructions as the number of orders in this batch.
     *
     * Emits a {SentOrderUnlock} event for each order in the batch.
     *
     * Requirements:
     * - The caller must be the taker of each order.
     * - Rewards and fees for each order must validate against the sent Ether value.
     */
    function sendBatchSolanaUnlock(
        DlnOrderLib.Order[] memory _orders,
        bytes32 _beneficiary,
        uint256 _executionFee,
        uint64 _initWalletIfNeededInstructionReward,
        uint64 _claimUnlockInstructionReward
    ) external payable nonReentrant whenNotPaused {
        if (_orders.length == 0) revert UnexpectedBatchSize();
        if (_orders.length > maxOrderCountPerBatchSolanaUnlock) revert UnexpectedBatchSize();
        // make sure execution fee covers rewards for single account initialisation instruction + claim_unlock for every order
        _validateSolanaRewards(msg.value, _executionFee, _initWalletIfNeededInstructionReward, uint64(_claimUnlockInstructionReward * _orders.length));

        uint256 giveChainId;
        bytes32 giveTokenAddress;
        bytes32 solanaSrcProgramId;
        bytes memory instructionsData;
        bytes32[] memory orderIds = new bytes32[](_orders.length);
        for (uint256 i; i < _orders.length; ++i) {
            DlnOrderLib.Order memory order = _orders[i];
            bytes32 orderId = DlnOrderLib.getOrderIdWithExternalCallHash(order);
            orderIds[i] = orderId;
            _prepareOrderStateForUnlock(orderId, DlnOrderLib.ChainEngine.SOLANA);

            if (i == 0) {
                // pre-cache giveChainId of the first order in a batch to ensure all other orders have the same giveChainId
                giveChainId = order.giveChainId;

                // pre-cache giveTokenAddress of the first order in a batch to ensure all other orders have the same giveTokenAddress
                // also, this value is used heavily when encoding instructions
                giveTokenAddress = BytesLib.toBytes32(order.giveTokenAddress, 0);

                // pre-cache solanaSrcProgramId because this value is used when encoding instructions
                solanaSrcProgramId = BytesLib.toBytes32(dlnSourceAddresses[order.giveChainId], 0);

                // first instruction must be account initializer.
                // actually by design, we must initialize account for every giveTokenAddress+beneficiary pair,
                // but right for simplicity reasons we assume that batches may contain orders with the same giveTokenAddress,
                // so only a single initialization is required
                instructionsData = EncodeSolanaDlnMessage.encodeInitWalletIfNeededInstruction(
                    _beneficiary,
                    giveTokenAddress,
                    _initWalletIfNeededInstructionReward
                );
            }
            else {
                // ensure every order is from the same chain
                if (order.giveChainId != giveChainId) revert WrongChain();

                // ensure every order has the same giveTokenAddress (otherwise, we may need to ensure this account is initalized)
                if (BytesLib.toBytes32(order.giveTokenAddress, 0) != giveTokenAddress) revert WrongToken();
            }

            // finally, add claim_unlock instruction for this order
            instructionsData = abi.encodePacked(
                instructionsData,
                EncodeSolanaDlnMessage.encodeClaimUnlockInstruction(
                    getChainId(), //_takeChainId,
                    solanaSrcProgramId, //_srcProgramId,
                    _beneficiary, //_actionBeneficiary,
                    giveTokenAddress, //_orderGiveTokenAddress,
                    orderId,
                    _claimUnlockInstructionReward
                )
            );
        }

        // send crosschain message through deBridgeGate
        bytes32 submissionId = _sendCrossChainMessage(
            giveChainId, // _chainIdTo
            abi.encodePacked(_beneficiary),
            _executionFee,
            instructionsData
        );

        // emit event for every order
        for (uint256 i; i < _orders.length; ++i) {
            emit SentOrderUnlock(orderIds[i], abi.encodePacked(_beneficiary), submissionId);
        }
    }


    /**
     * @dev Unlocks a fulfilled order that was created from the Solana blockchain and filled on EVM.
     * Once an order is filled in EVM and not yet unlocked, the taker can call this function to unlock
     * and claim the order's give part on Solana. The function prepares cross-chain instructions
     * to handle the unlock on Solana.
     *
     * @param _order The order to be unlocked.
     * @param _beneficiary The recipient of the give amount in the Solana chain.
     * @param _executionFee Fee for the cross-chain execution by keepers.
     * @param _initWalletIfNeededInstructionReward Reward for executing the `init_wallet_if_needed` instruction on Solana.
     * @param _claimUnlockInstructionReward Reward for executing the `claim_unlock` instruction on Solana.
     *
     * Emits a {SentOrderUnlock} event.
     *
     * Requirements:
     * - The caller must be the taker of the order.
     * - Rewards and fees must validate against the sent Ether value.
     */
    function sendSolanaUnlock(
        DlnOrderLib.Order memory _order,
        bytes32 _beneficiary,
        uint256 _executionFee,
        uint64 _initWalletIfNeededInstructionReward,
        uint64 _claimUnlockInstructionReward
    ) external payable nonReentrant whenNotPaused {
        _validateSolanaRewards(msg.value, _executionFee, _initWalletIfNeededInstructionReward, _claimUnlockInstructionReward);
        bytes32 orderId = DlnOrderLib.getOrderIdWithExternalCallHash(_order);
        uint256 giveChainId = _prepareOrderStateForUnlock(orderId, DlnOrderLib.ChainEngine.SOLANA);

        // encode function that will be called in target chain
        bytes32 giveTokenAddress = BytesLib.toBytes32(_order.giveTokenAddress, 0);
        bytes memory instructionsData = abi.encodePacked(
            EncodeSolanaDlnMessage.encodeInitWalletIfNeededInstruction(
                    _beneficiary,
                    giveTokenAddress,
                    _initWalletIfNeededInstructionReward
            ),
            EncodeSolanaDlnMessage.encodeClaimUnlockInstruction(
                getChainId(), //_takeChainId,
                BytesLib.toBytes32(dlnSourceAddresses[giveChainId], 0), //_srcProgramId,
                _beneficiary, //_actionBeneficiary,
                giveTokenAddress, //_orderGiveTokenAddress,
                orderId,
                _claimUnlockInstructionReward
            )
        );
        //send crosschain message through deBridgeGate
        bytes32 submissionId = _sendCrossChainMessage(
            giveChainId, // _chainIdTo
            abi.encodePacked(_beneficiary),
            _executionFee,
            instructionsData
        );

        emit SentOrderUnlock(orderId, abi.encodePacked(_beneficiary), submissionId);
    }


    /**
     * @dev Cancels an order on the destination chain if it hasn't been filled or previously cancelled.
     * The order's authority address on the destination chain can call this function to reclaim the
     * locked funds. The function prepares cross-chain instructions for order cancellation.
     *
     * @param _order The full order details.
     * @param _cancelBeneficiary The recipient of the refund in the give chain.
     * @param _executionFee Fee for the cross-chain execution by keepers.
     *
     * Emits a {SentOrderCancel} event.
     *
     * Requirements:
     * - The caller must be the `order_authority_address_dst` of the order.
     * - The order's `takeChainId` must match the current chain ID.
     * - The order's `giveChainId` must be of type EVM.
     * - If specified, only the `allowed_cancel_beneficiary` can be the beneficiary.
     * - Order status must be `NotSet`.
     */
    function sendEvmOrderCancel(
        DlnOrderLib.Order memory _order,
        address _cancelBeneficiary,
        uint256 _executionFee
    ) external payable nonReentrant whenNotPaused {
        if (_order.takeChainId != getChainId()) revert WrongChain();
        if (chainEngines[_order.giveChainId]  != DlnOrderLib.ChainEngine.EVM) revert WrongChain();
        bytes32 orderId = DlnOrderLib.getOrderId(_order);
        if (_order.orderAuthorityAddressDst.toAddress() != msg.sender)
            revert Unauthorized();

        if (_order.allowedCancelBeneficiarySrc.length > 0
            && _order.allowedCancelBeneficiarySrc.toAddress() != _cancelBeneficiary) {
            revert AllowOnlyForBeneficiary(_order.allowedCancelBeneficiarySrc);
        }

        OrderTakeState storage orderState = takeOrders[orderId];
        //In dst chain order will start from 0-NotSet
        if (orderState.status != OrderTakeStatus.NotSet) revert IncorrectOrderStatus();
        orderState.status = OrderTakeStatus.SentCancel;

        // encode function that will be called in target chain
        bytes memory claimCancelMethod = _encodeClaimCancel(orderId, _cancelBeneficiary);
        //send crosschain message through deBridgeGate
        bytes32 submissionId = _sendCrossChainMessage(
            _order.giveChainId, // _chainIdTo
            abi.encodePacked(_cancelBeneficiary),
            _executionFee,
            claimCancelMethod
        );
        emit SentOrderCancel(_order, orderId, abi.encodePacked(_cancelBeneficiary), submissionId);
    }

    /**
     * @dev Sends a request to cancel an order on the Solana blockchain.
     * If an order hasn't been filled or canceled previously, the `orderAuthorityAddressDst`
     * can invoke this function to cancel it, thereby retrieving the 'give' part of the order
     * back on the Solana chain. Subsequently, the `dln::source::claim_order_cancel` function
     * will be triggered on the Solana side.
     *
     * @param _order The order details to be canceled.
     * @param _cancelBeneficiary The address designated to receive the refund on the Solana chain.
     *        If the order's `allowedCancelBeneficiarySrc` is unspecified, any address can be the beneficiary.
     *        However, if specified, only the mentioned address can be the beneficiary.
     * @param _executionFee Fee for executing the cancellation, typically claimed by keepers.
     * @param _initWalletIfNeededInstructionReward Reward for executing the `init_wallet_if_needed` instruction on Solana.
     * @param _claimCancelInstructionReward Reward for claiming the cancel instruction.
     *
     * Requirements:
     * - Caller must be the `orderAuthorityAddressDst` of the order.
     * - The order's `takeChainId` must match the current chain's ID.
     * - The `giveChainId` of the order must correspond to Solana.
     * - If `allowedCancelBeneficiarySrc` is specified in the order, it must match the provided `_cancelBeneficiary`.
     */
    function sendSolanaOrderCancel(
        DlnOrderLib.Order memory _order,
        bytes32 _cancelBeneficiary,
        uint256 _executionFee,
        uint64 _initWalletIfNeededInstructionReward,
        uint64 _claimCancelInstructionReward
    ) external payable nonReentrant whenNotPaused {
        _validateSolanaRewards(msg.value, _executionFee, _initWalletIfNeededInstructionReward, _claimCancelInstructionReward);

        if (chainEngines[_order.giveChainId]  != DlnOrderLib.ChainEngine.SOLANA) revert WrongChain();
        if (_order.takeChainId != getChainId()) revert WrongChain();
        bytes memory solanaSrcProgramId = dlnSourceAddresses[_order.giveChainId];
        if (solanaSrcProgramId.length != SOLANA_ADDRESS_LENGTH) revert WrongChain();

        bytes32 orderId = DlnOrderLib.getOrderId(_order);
        if (_order.orderAuthorityAddressDst.toAddress() != msg.sender)
            revert Unauthorized();

        if (_order.allowedCancelBeneficiarySrc.length > 0
            && BytesLib.toBytes32(_order.allowedCancelBeneficiarySrc, 0) != _cancelBeneficiary) {
            revert AllowOnlyForBeneficiary(_order.allowedCancelBeneficiarySrc);
        }

        OrderTakeState storage orderState = takeOrders[orderId];
        //In dst chain order will start from 0-NotSet
        if (orderState.status != OrderTakeStatus.NotSet) revert IncorrectOrderStatus();
        orderState.status = OrderTakeStatus.SentCancel;

        // encode function that will be called in target chain
        bytes32 _orderGiveTokenAddress = BytesLib.toBytes32(_order.giveTokenAddress, 0);
        bytes memory claimCancelMethod = abi.encodePacked(
            EncodeSolanaDlnMessage.encodeInitWalletIfNeededInstruction(
                    _cancelBeneficiary,
                    _orderGiveTokenAddress,
                    _initWalletIfNeededInstructionReward
            ),
            EncodeSolanaDlnMessage.encodeClaimCancelInstruction(
                getChainId(), //_takeChainId,
                BytesLib.toBytes32(solanaSrcProgramId, 0), //_srcProgramId,
                _cancelBeneficiary, //_actionBeneficiary,
                _orderGiveTokenAddress, //_orderGiveTokenAddress,
                orderId,
                _claimCancelInstructionReward
            )
        );
        //send crosschain message through deBridgeGate
        bytes32 submissionId = _sendCrossChainMessage(
            _order.giveChainId, // _chainIdTo
            abi.encodePacked(_cancelBeneficiary),
            _executionFee,
            claimCancelMethod
        );

        emit SentOrderCancel(_order, orderId, abi.encodePacked(_cancelBeneficiary), submissionId);
    }

    /**
     * @dev Modifies an order's take offer.
     *
     * This function allows reducing the value of the 'takeAmount' of an order, potentially
     * making the order more profitable. If a patch was applied to the order previously,
     * subsequent patches can only further reduce the offer.
     *
     * @param _order Full order information
     * @param _newSubtrahend Amount to be subtracted from the original [`Order.takeAmount`],
     *        which adjusts the amount required in the `fulfillOrder` methods.
     *
     * # Restrictions
     * Only the `orderAuthorityAddressDst` can invoke this function.
     */
    function patchOrderTake(DlnOrderLib.Order memory _order, uint256 _newSubtrahend)
        external
        nonReentrant
        whenNotPaused
    {
        if (_order.takeChainId != getChainId()) revert WrongChain();
        bytes32 orderId = DlnOrderLib.getOrderIdWithExternalCallHash(_order);
        if (_order.orderAuthorityAddressDst.toAddress() != msg.sender)
            revert Unauthorized();
        if (takePatches[orderId] >= _newSubtrahend) revert WrongArgument();
        if (_order.takeAmount <= _newSubtrahend) revert WrongArgument();
        //In dst chain order will start from 0-NotSet
        if (takeOrders[orderId].status != OrderTakeStatus.NotSet) revert IncorrectOrderStatus();

        takePatches[orderId] = _newSubtrahend;
        emit DecreasedTakeAmount(orderId, _order.takeAmount - takePatches[orderId]);
    }

    /* ========== ADMIN METHODS ========== */

    function setDlnSourceAddress(uint256 _chainIdFrom, bytes memory _dlnSourceAddress, DlnOrderLib.ChainEngine _chainEngine)
        external
        onlyAdmin
    {
        if(_chainEngine == DlnOrderLib.ChainEngine.UNDEFINED) revert WrongArgument();
        dlnSourceAddresses[_chainIdFrom] = _dlnSourceAddress;
        chainEngines[_chainIdFrom] = _chainEngine;
        emit SetDlnSourceAddress(_chainIdFrom, _dlnSourceAddress, _chainEngine);
    }

    function setExternalCallAdapter(address _externalCallAdapter)
        external
        onlyAdmin
    {
        address oldAdapter = externalCallAdapter;
        externalCallAdapter = _externalCallAdapter;
        emit ExternalCallAdapterUpdated(oldAdapter, externalCallAdapter);
    }

    function setMaxOrderCountsPerBatch(uint256 _newEvmCount, uint256 _newSolanaCount) external onlyAdmin {
        // Setting and emitting for EVM count
        uint256 oldEvmValue = maxOrderCountPerBatchEvmUnlock;
        maxOrderCountPerBatchEvmUnlock = _newEvmCount;
        if(oldEvmValue != _newEvmCount) {
            emit MaxOrderCountPerBatchEvmUnlockChanged(oldEvmValue, _newEvmCount);
        }

        // Setting and emitting for Solana count
        uint256 oldSolanaValue = maxOrderCountPerBatchSolanaUnlock;
        maxOrderCountPerBatchSolanaUnlock = _newSolanaCount;
        if(oldSolanaValue != _newSolanaCount) {
            emit MaxOrderCountPerBatchSolanaUnlockChanged(oldSolanaValue, _newSolanaCount);
        }
    }


    /// @dev Get current chain id
    function getChainId() public view virtual returns (uint256 cid) {
        cid = subscriptionId;
        if (cid != 0) return cid;

        assembly {
            cid := chainid()
        }
    }

    /* ==========  Private methods ========== */

    /**
     * @dev Change the order's status from "Fulfilled" to "SentUnlock".
     * @notice Only the taker of the order can call this.
     * @param _orderId The unique identifier of the order being processed.
     * @return Returns the 'giveChainId' from the order.
     */
    function _prepareOrderStateForUnlock(bytes32 _orderId, DlnOrderLib.ChainEngine _chainEngine) internal
        returns (uint256) {
        OrderTakeState storage orderState = takeOrders[_orderId];
        if (orderState.status != OrderTakeStatus.Fulfilled) revert IncorrectOrderStatus();
        if (orderState.takerAddress != msg.sender) revert Unauthorized();
        uint256 giveChainIdValue = orderState.giveChainId > 0 
            ? uint256(orderState.giveChainId)
            : orderState.bigGiveChainId;
        if (chainEngines[giveChainIdValue] != _chainEngine) revert WrongChain();
        orderState.status = OrderTakeStatus.SentUnlock;
        return giveChainIdValue;
    }

    function _encodeClaimUnlock(bytes32 _orderId, address _beneficiary)
        internal
        pure
        returns (bytes memory)
    {
        //claimUnlock(bytes32 _orderId, address _beneficiary)
        return abi.encodeWithSelector(DlnSource.claimUnlock.selector, _orderId, _beneficiary);
    }

    function _encodeBatchClaimUnlock(bytes32[] memory _orderIds, address _beneficiary)
        internal
        pure
        returns (bytes memory)
    {
        //claimBatchUnlock(bytes32[] memory _orderIds, address _beneficiary)
        return abi.encodeWithSelector(DlnSource.claimBatchUnlock.selector, _orderIds, _beneficiary);
    }


    function _encodeClaimCancel(bytes32 _orderId, address _beneficiary)
        internal
        pure
        returns (bytes memory)
    {
        //claimCancel(bytes32 _orderId, address _beneficiary)
        return abi.encodeWithSelector(DlnSource.claimCancel.selector, _orderId, _beneficiary);
    }

    function _encodeAutoParamsTo(
        bytes memory _data,
        uint256 _executionFee,
        bytes memory _fallbackAddress
    ) internal pure returns (bytes memory) {
        IDeBridgeGate.SubmissionAutoParamsTo memory autoParams;
        autoParams.flags = Flags.setFlag(autoParams.flags, Flags.REVERT_IF_EXTERNAL_FAIL, true);
        autoParams.flags = Flags.setFlag(autoParams.flags, Flags.PROXY_WITH_SENDER, true);

        // fallbackAddress won't be used because of REVERT_IF_EXTERNAL_FAIL flag
        // also it make no sense to use it because it's only for ERC20 tokens
        // autoParams.fallbackAddress = abi.encodePacked(address(0));
        autoParams.fallbackAddress = _fallbackAddress;
        autoParams.data = _data;
        autoParams.executionFee = _executionFee;
        return abi.encode(autoParams);
    }

    /**
     * @dev Validates whether the provided amount is sufficient to cover all execution rewards.
     * @param _inputAmount Amount being transferred, which should cover the execution fee and all rewards.
     * @param _executionFee Fee required for the claim execution.
     * @param _solanaExternalCallReward1 Fee for executing the first external call on Solana.
     * @param _solanaExternalCallReward2 Fee for executing the second external call on Solana.
     */
    function _validateSolanaRewards (
        uint256 _inputAmount,
        uint256 _executionFee,
        uint64 _solanaExternalCallReward1,
        uint64 _solanaExternalCallReward2
    ) internal view {
        uint256 transferFeeBPS = deBridgeGate.globalTransferFeeBps();
        uint256 fixFee = deBridgeGate.globalFixedNativeFee();
        if (_inputAmount < fixFee) revert TransferAmountNotCoverFees();
        uint256 transferFee = transferFeeBPS * (_inputAmount - fixFee) / BPS_DENOMINATOR;
        if (_inputAmount / NATIVE_AMOUNT_DIVIDER_FOR_TRANSFER_TO_SOLANA < (fixFee + transferFee + _executionFee) / NATIVE_AMOUNT_DIVIDER_FOR_TRANSFER_TO_SOLANA
                                                        + _solanaExternalCallReward1 + _solanaExternalCallReward2) {
            revert TransferAmountNotCoverFees();
        }
    }

    function _sendCrossChainMessage(
        uint256 _chainIdTo,
        bytes memory _fallbackAddress,
        uint256 _executionFee,
        bytes memory _data
    ) internal returns (bytes32) {
        bytes memory srcAddress = dlnSourceAddresses[_chainIdTo];
        bytes memory autoParams = _encodeAutoParamsTo(_data, _executionFee, _fallbackAddress);
        {
            DlnOrderLib.ChainEngine _targetEngine = chainEngines[_chainIdTo];

            if (_targetEngine == DlnOrderLib.ChainEngine.EVM ) {
                if (srcAddress.length != EVM_ADDRESS_LENGTH) revert DlnOrderLib.WrongAddressLength();
                if (_fallbackAddress.length != EVM_ADDRESS_LENGTH) revert DlnOrderLib.WrongAddressLength();
            }
            else if (_targetEngine == DlnOrderLib.ChainEngine.SOLANA ) {
                if (srcAddress.length != SOLANA_ADDRESS_LENGTH) revert DlnOrderLib.WrongAddressLength();
                if (_fallbackAddress.length != SOLANA_ADDRESS_LENGTH) revert DlnOrderLib.WrongAddressLength();
            }
            else {
                revert UnknownEngine();
            }
        }

        return deBridgeGate.send{value: msg.value}(
            address(0), // _tokenAddress
            msg.value, // _amount
            _chainIdTo, // _chainIdTo
            srcAddress, // _receiver
            "", // _permit
            false, // _useAssetFee
            0, // _referralCode
            autoParams // _autoParams
        );
    }

    /* ========== Version Control ========== */

    /// @dev Get this contract's version
    function version() external pure returns (string memory) {
        return "1.4.0";
    }
}
